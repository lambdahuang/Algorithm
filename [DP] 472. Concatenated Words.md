Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.

A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.

```
Example:
Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]

Explanation: 
"catsdogcats" can be concatenated by "cats", "dog" and "cats"; 

"dogcatsdog" can be concatenated by "dog", "cats" and "dog"; 
 
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
```

__Note:__
>1.The number of elements of the given array will not exceed 10,000

>2.The length sum of elements in the given array will not exceed 600,000.

>3.All the input string will only include lower case letters.

>4.The returned elements order does not matter.

__My idea__

It feels so easy when I was first seeing this question. It feels like that the question is modestly different from classic DP question, in which using DP for each string. After I finish the first version, it turns out that I'm naive, the time complexity is too high, which reaches O(n^2 * m^2)(.. two words array iteration, two words' characters iteration).

After glimpse the discussion board, I adopt one guy's idea that sorting before processing and using ___HashSet___ to maintain the states of the words that already processed. Consider that we only care about whether or not the substring could be concatenated by other strings in arrays, therefore the status of such sub-problem is a boolean typeï¼ŒI use bit munipulation to hold the status instead of using the boolean array.

__My Solution__
```
public List<String> findAllConcatenatedWordsInADict(String[] words) {
        if(words.length == 0)
            return new LinkedList();
        Arrays.sort(words, new Comparator<String>(){
            public int compare (String s1, String s2)
            {
                return s1.length() - s2.length();
            }
        });
        List<String> ret = new LinkedList();
        Set<String> previous_processed_words = new HashSet<>();
        
        for(int i = 0; i < words.length; i++)
        {
            int map = 1;    // using bit munipluation instead of boolean array to map the status
            int len = words[i].length();
            for(int n = 1; n <= len; n++)
            {
                for(int k = 0; k < n; k ++)
                {
                    if((map & (1 << k)) != 0 &&
                    previous_processed_words.contains(words[i].substring(k, n)) == true
                    )
                    {
                        map |= (1 << n);
                        if(n == len)
                        {
                            ret.add(words[i]);
                        }
                        break;
                    }
                }
            }
            previous_processed_words.add(words[i]);
        }
        return ret;
    }
```
